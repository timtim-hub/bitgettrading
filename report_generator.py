"""
Report Generator - Generate comprehensive markdown reports from backtest results
"""

from typing import Dict, List, Any
from datetime import datetime
from pathlib import Path
from metrics_calculator import PerformanceMetrics


class ReportGenerator:
    """Generate comprehensive markdown reports from backtest results."""
    
    def __init__(self, results_dir: str = "backtest_results"):
        self.results_dir = Path(results_dir)
        self.results_dir.mkdir(exist_ok=True)
    
    def generate_report(
        self,
        all_metrics: List[PerformanceMetrics],
        aggregated: Dict[int, Dict[str, Any]],
        data_path: str
    ) -> str:
        """
        Generate comprehensive markdown report.
        
        Args:
            all_metrics: List of all individual backtest metrics
            aggregated: Aggregated metrics by strategy
            data_path: Path to detailed data file
            
        Returns:
            Path to generated report
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_path = self.results_dir / f"backtest_report_{timestamp}.md"
        
        with open(report_path, 'w') as f:
            # Header
            f.write(f"# Backtest Results Report\n\n")
            f.write(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write(f"---\n\n")
            
            # Executive Summary
            f.write(self._generate_executive_summary(all_metrics, aggregated))
            
            # Top Strategies Rankings
            f.write(self._generate_top_strategies_by_roi(aggregated))
            f.write(self._generate_top_strategies_by_win_rate(aggregated))
            f.write(self._generate_top_strategies_by_sharpe(aggregated))
            f.write(self._generate_top_strategies_by_trades(aggregated))
            
            # Detailed Strategy Results
            f.write(self._generate_detailed_strategy_results(aggregated))
            
            # Symbol Analysis
            f.write(self._generate_symbol_analysis(all_metrics))
            
            # Strategy Parameter Analysis
            f.write(self._generate_parameter_analysis(aggregated, all_metrics))
            
            # Best Strategies Summary
            f.write(self._generate_best_strategies_summary(aggregated))
            
            # Footer
            f.write(f"\n---\n\n")
            f.write(f"**Data source:** {data_path}\n")
            f.write(f"**Report generated by:** Advanced Backtesting System v1.0\n")
        
        return str(report_path)
    
    def _generate_executive_summary(self, all_metrics: List[PerformanceMetrics], aggregated: Dict) -> str:
        """Generate executive summary section."""
        num_strategies = len(aggregated)
        num_symbols = len(set(m.symbol for m in all_metrics))
        total_backtests = len(all_metrics)
        
        # Get date range from first metric
        if all_metrics:
            initial_capital = all_metrics[0].initial_capital
        else:
            initial_capital = 50.0
        
        # Find best overall strategy
        best_strategy = max(aggregated.values(), key=lambda x: x['avg_roi_pct'])
        
        md = "## ğŸ“Š Executive Summary\n\n"
        md += f"- **Total Strategies Tested:** {num_strategies}\n"
        md += f"- **Total Symbols Tested:** {num_symbols}\n"
        md += f"- **Total Backtests Run:** {total_backtests}\n"
        md += f"- **Initial Capital per Account:** ${initial_capital:.2f}\n"
        md += f"- **Best Strategy:** {best_strategy['strategy_name']} (Avg ROI: {best_strategy['avg_roi_pct']:.2f}%)\n"
        md += "\n---\n\n"
        return md
    
    def _generate_top_strategies_by_roi(self, aggregated: Dict) -> str:
        """Generate top 10 strategies by ROI."""
        md = "## ğŸ† Top 10 Strategies by ROI\n\n"
        
        # Sort by average ROI
        sorted_strategies = sorted(aggregated.values(), key=lambda x: x['avg_roi_pct'], reverse=True)[:10]
        
        md += "| Rank | Strategy | Avg ROI % | Total Trades | Win Rate % | Avg Sharpe | Avg Max DD % | Trades/Day |\n"
        md += "|------|----------|-----------|--------------|------------|------------|--------------|------------|\n"
        
        for rank, strategy in enumerate(sorted_strategies, 1):
            md += f"| {rank} | {strategy['strategy_name']} | "
            md += f"{strategy['avg_roi_pct']:.2f} | "
            md += f"{strategy['total_trades']} | "
            md += f"{strategy['avg_win_rate_pct']:.2f} | "
            md += f"{strategy['avg_sharpe']:.2f} | "
            md += f"{strategy['avg_max_dd_pct']:.2f} | "
            md += f"{strategy['avg_trades_per_day']:.2f} |\n"
        
        md += "\n---\n\n"
        return md
    
    def _generate_top_strategies_by_win_rate(self, aggregated: Dict) -> str:
        """Generate top 10 strategies by win rate."""
        md = "## ğŸ¯ Top 10 Strategies by Win Rate\n\n"
        
        # Sort by win rate
        sorted_strategies = sorted(aggregated.values(), key=lambda x: x['avg_win_rate_pct'], reverse=True)[:10]
        
        md += "| Rank | Strategy | Win Rate % | Avg ROI % | Total Trades | Avg Profit Factor | Trades/Day |\n"
        md += "|------|----------|------------|-----------|--------------|-------------------|------------|\n"
        
        for rank, strategy in enumerate(sorted_strategies, 1):
            md += f"| {rank} | {strategy['strategy_name']} | "
            md += f"{strategy['avg_win_rate_pct']:.2f} | "
            md += f"{strategy['avg_roi_pct']:.2f} | "
            md += f"{strategy['total_trades']} | "
            md += f"{strategy['avg_profit_factor']:.2f} | "
            md += f"{strategy['avg_trades_per_day']:.2f} |\n"
        
        md += "\n---\n\n"
        return md
    
    def _generate_top_strategies_by_sharpe(self, aggregated: Dict) -> str:
        """Generate top 10 strategies by Sharpe ratio."""
        md = "## ğŸ“ˆ Top 10 Strategies by Sharpe Ratio\n\n"
        
        # Sort by Sharpe ratio
        sorted_strategies = sorted(aggregated.values(), key=lambda x: x['avg_sharpe'], reverse=True)[:10]
        
        md += "| Rank | Strategy | Sharpe | Sortino | Avg ROI % | Win Rate % | Avg Max DD % |\n"
        md += "|------|----------|--------|---------|-----------|------------|---------------|\n"
        
        for rank, strategy in enumerate(sorted_strategies, 1):
            md += f"| {rank} | {strategy['strategy_name']} | "
            md += f"{strategy['avg_sharpe']:.2f} | "
            md += f"{strategy['avg_sortino']:.2f} | "
            md += f"{strategy['avg_roi_pct']:.2f} | "
            md += f"{strategy['avg_win_rate_pct']:.2f} | "
            md += f"{strategy['avg_max_dd_pct']:.2f} |\n"
        
        md += "\n---\n\n"
        return md
    
    def _generate_top_strategies_by_trades(self, aggregated: Dict) -> str:
        """Generate top 10 most active strategies."""
        md = "## ğŸ”„ Top 10 Most Active Strategies (by Trade Frequency)\n\n"
        
        # Sort by trades per day
        sorted_strategies = sorted(aggregated.values(), key=lambda x: x['avg_trades_per_day'], reverse=True)[:10]
        
        md += "| Rank | Strategy | Trades/Day | Trades/Hour | Total Trades | Win Rate % | Avg ROI % |\n"
        md += "|------|----------|------------|-------------|--------------|------------|------------|\n"
        
        for rank, strategy in enumerate(sorted_strategies, 1):
            md += f"| {rank} | {strategy['strategy_name']} | "
            md += f"{strategy['avg_trades_per_day']:.2f} | "
            md += f"{strategy['avg_trades_per_hour']:.3f} | "
            md += f"{strategy['total_trades']} | "
            md += f"{strategy['avg_win_rate_pct']:.2f} | "
            md += f"{strategy['avg_roi_pct']:.2f} |\n"
        
        md += "\n---\n\n"
        return md
    
    def _generate_detailed_strategy_results(self, aggregated: Dict) -> str:
        """Generate detailed results for all strategies."""
        md = "## ğŸ“‹ Detailed Strategy Results\n\n"
        
        # Group by category
        categories = {
            'Conservative': [],
            'Balanced': [],
            'Aggressive': [],
            'UltraAggressive': []
        }
        
        for strategy in aggregated.values():
            name = strategy['strategy_name']
            category = name.split('_')[0]
            if category in categories:
                categories[category].append(strategy)
        
        for category, strategies in categories.items():
            if not strategies:
                continue
            
            md += f"### {category} Strategies\n\n"
            md += "| Strategy | Avg ROI % | Win Rate % | Total Trades | Sharpe | Max DD % | Best Symbol | Worst Symbol |\n"
            md += "|----------|-----------|------------|--------------|--------|----------|-------------|---------------|\n"
            
            # Sort by ROI within category
            strategies.sort(key=lambda x: x['avg_roi_pct'], reverse=True)
            
            for strategy in strategies:
                md += f"| {strategy['strategy_name']} | "
                md += f"{strategy['avg_roi_pct']:.2f} | "
                md += f"{strategy['avg_win_rate_pct']:.2f} | "
                md += f"{strategy['total_trades']} | "
                md += f"{strategy['avg_sharpe']:.2f} | "
                md += f"{strategy['avg_max_dd_pct']:.2f} | "
                md += f"{strategy['best_symbol']} ({strategy['best_symbol_roi']:.2f}%) | "
                md += f"{strategy['worst_symbol']} ({strategy['worst_symbol_roi']:.2f}%) |\n"
            
            md += "\n"
        
        md += "---\n\n"
        return md
    
    def _generate_symbol_analysis(self, all_metrics: List[PerformanceMetrics]) -> str:
        """Generate symbol-by-symbol analysis."""
        md = "## ğŸª™ Symbol Analysis\n\n"
        
        # Group by symbol
        symbol_data = {}
        for metrics in all_metrics:
            if metrics.symbol not in symbol_data:
                symbol_data[metrics.symbol] = []
            symbol_data[metrics.symbol].append(metrics)
        
        md += "| Symbol | Avg ROI % | Avg Win Rate % | Total Trades | Best Strategy | Best ROI % |\n"
        md += "|--------|-----------|----------------|--------------|---------------|-------------|\n"
        
        for symbol in sorted(symbol_data.keys()):
            metrics_list = symbol_data[symbol]
            avg_roi = sum(m.total_roi_pct for m in metrics_list) / len(metrics_list)
            avg_win_rate = sum(m.win_rate_pct for m in metrics_list) / len(metrics_list)
            total_trades = sum(m.total_trades for m in metrics_list)
            
            # Find best strategy for this symbol
            best = max(metrics_list, key=lambda x: x.total_roi_pct)
            
            md += f"| {symbol} | {avg_roi:.2f} | {avg_win_rate:.2f} | {total_trades} | "
            md += f"{best.strategy_name} | {best.total_roi_pct:.2f} |\n"
        
        md += "\n---\n\n"
        return md
    
    def _generate_parameter_analysis(self, aggregated: Dict, all_metrics: List[PerformanceMetrics]) -> str:
        """Analyze which parameters lead to best results."""
        md = "## ğŸ”§ Strategy Parameter Analysis\n\n"
        
        md += "### Key Findings\n\n"
        
        # Analyze entry thresholds
        md += "#### Entry Threshold Impact\n\n"
        md += "Analysis of how entry threshold affects performance across all strategies.\n\n"
        
        # This would require loading strategy configs, simplified for now
        md += "*Detailed parameter analysis available in raw data files.*\n\n"
        
        md += "---\n\n"
        return md
    
    def _generate_best_strategies_summary(self, aggregated: Dict) -> str:
        """Generate final recommendation summary."""
        md = "## âœ¨ Recommended Strategies for Live Trading\n\n"
        
        # Get top 3 by different metrics
        top_roi = sorted(aggregated.values(), key=lambda x: x['avg_roi_pct'], reverse=True)[0]
        top_win_rate = sorted(aggregated.values(), key=lambda x: x['avg_win_rate_pct'], reverse=True)[0]
        top_sharpe = sorted(aggregated.values(), key=lambda x: x['avg_sharpe'], reverse=True)[0]
        
        # Find best overall (balanced score)
        for strategy in aggregated.values():
            # Composite score: ROI * 0.4 + Win Rate * 0.3 + Sharpe * 0.3
            strategy['composite_score'] = (
                strategy['avg_roi_pct'] * 0.4 +
                strategy['avg_win_rate_pct'] * 0.3 +
                strategy['avg_sharpe'] * 10 * 0.3  # Scale Sharpe to ~same range
            )
        
        best_overall = max(aggregated.values(), key=lambda x: x['composite_score'])
        
        md += "### ğŸ¥‡ Best Overall Strategy (Balanced Score)\n\n"
        md += f"**{best_overall['strategy_name']}**\n\n"
        md += f"- **Avg ROI:** {best_overall['avg_roi_pct']:.2f}%\n"
        md += f"- **Win Rate:** {best_overall['avg_win_rate_pct']:.2f}%\n"
        md += f"- **Sharpe Ratio:** {best_overall['avg_sharpe']:.2f}\n"
        md += f"- **Max Drawdown:** {best_overall['avg_max_dd_pct']:.2f}%\n"
        md += f"- **Trades/Day:** {best_overall['avg_trades_per_day']:.2f}\n"
        md += f"- **Total Trades:** {best_overall['total_trades']}\n\n"
        
        md += "### ğŸ’° Highest ROI Strategy\n\n"
        md += f"**{top_roi['strategy_name']}** - {top_roi['avg_roi_pct']:.2f}% avg ROI\n\n"
        
        md += "### ğŸ¯ Highest Win Rate Strategy\n\n"
        md += f"**{top_win_rate['strategy_name']}** - {top_win_rate['avg_win_rate_pct']:.2f}% win rate\n\n"
        
        md += "### ğŸ“Š Best Risk-Adjusted Returns (Sharpe)\n\n"
        md += f"**{top_sharpe['strategy_name']}** - {top_sharpe['avg_sharpe']:.2f} Sharpe ratio\n\n"
        
        md += "---\n\n"
        md += "### ğŸ’¡ Recommendation\n\n"
        md += f"For live trading, consider deploying **{best_overall['strategy_name']}** "
        md += f"as it offers the best balance of profitability, consistency, and risk management.\n\n"
        md += "### âš ï¸ Important Notes\n\n"
        md += "- Past performance does not guarantee future results\n"
        md += "- Always start with small position sizes in live trading\n"
        md += "- Monitor performance closely and be ready to adjust\n"
        md += "- Consider market conditions and volatility\n\n"
        
        return md


if __name__ == "__main__":
    print("Report generator module. Run advanced_backtester.py to generate reports.")

